//
// File: HS_EWL_FREQ_ACQ.cpp
//
// MATLAB Coder version            : 5.1
// C/C++ source code generated on  : 06-May-2022 14:49:51
//

// Include Files
#include "HS_EWL_FREQ_ACQ.h"
#include "FIRDecimator.h"
#include "HS_EWL_DEMOD_QAM.h"
#include "HS_EWL_DEMOD_QAM_data.h"
#include "HS_EWL_DEMOD_QAM_emxutil.h"
#include "HS_EWL_DEMOD_QAM_initialize.h"
#include "HS_EWL_DEMOD_QAM_rtwutil.h"
#include "HS_EWL_DEMOD_QAM_types.h"
#include "RaisedCosineReceiveFilter.h"
#include "minOrMax.h"
#include "qammod.h"
#include "rat.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <cmath>

// Constants
static const double dv[1001] = { 36.999398630366194, 36.957771062942847,
  36.915723654879763, 36.873280846438, 36.8304670778786, 36.78730678946264,
  36.743824421451151, 36.700044414105207, 36.655991207685858,
  36.611689242454155, 36.567162958671155, 36.522436796597916,
  36.477535196495488, 36.432482598624937, 36.387303443247305,
  36.34202217062365, 36.296663221015038, 36.251251034682511,
  36.205810051887134, 36.160364712889958, 36.114939457952033,
  36.069558727334424, 36.024246961298175, 35.979028600104357,
  35.93390340947888, 35.888772457007157, 35.843512135739438,
  35.797998838725995, 35.7521089590171, 35.705718889663011, 35.658705023713992,
  35.610943754220308, 35.562311474232231, 35.512684576800027,
  35.461980657860472, 35.410282124896518, 35.357712588277607,
  35.304395658373224, 35.250454945552818, 35.196014060185853, 35.1411966126418,
  35.086126213290115, 35.030926472500269, 34.975721000641727, 34.9206074536145,
  34.865579669440841, 34.810605531673531, 34.75565292386537,
  34.700689729569149, 34.645683832337667, 34.590603115723709,
  34.535415463280074, 34.480088758559553, 34.424590885114945,
  34.368896589307127, 34.313008068729346, 34.256934383782962, 34.2006845948693,
  34.144267762389731, 34.08769294674557, 34.030969208338171, 33.97410560756888,
  33.917111204839046, 33.859995060550006, 33.80276452478828, 33.7454201063811,
  33.68796060384085, 33.630384815679946, 33.572691540410794,
  33.514879576545773, 33.456947722597292, 33.398894777077757,
  33.340719538499563, 33.282420805375111, 33.223997626886806,
  33.165450054897079, 33.106778391938342, 33.047982940543029,
  32.98906400324357, 32.930021882572383, 32.870856881061904, 32.81156930124456,
  32.752159445652772, 32.692627616818967, 32.632974395649313,
  32.573201476544888, 32.513310832280531, 32.453304435631054,
  32.393184259371296, 32.332952276276067, 32.272610459120195,
  32.212160780678509, 32.15160521372583, 32.090945731036989,
  32.030183793928167, 31.96931881788106, 31.908349706918703,
  31.847275365064153, 31.786094696340463, 31.724806604770674,
  31.663409994377837, 31.601903769185004, 31.540286833215223,
  31.478558090491553, 31.416716930939273, 31.354764688092679,
  31.292703181388294, 31.230534230262656, 31.16825965415229,
  31.105881272493725, 31.043400904723494, 30.980820370278128,
  30.918141488594156, 30.855366079108109, 30.79249548979762,
  30.729529182804761, 30.666466148812702, 30.603305378504615,
  30.54004586256368, 30.476686591673058, 30.41322655651593, 30.349664747775467,
  30.286000156134843, 30.222231772277233, 30.158359082655732,
  30.094383556803141, 30.030307160022197, 29.966131857615625,
  29.90185961488616, 29.837492397136522, 29.773032169669449,
  29.708480897787666, 29.643840546793907, 29.579113081990904,
  29.514300311431064, 29.449403414165555, 29.384423411995229,
  29.319361326720937, 29.254218180143528, 29.188994994063847,
  29.12369279028275, 29.058312590601087, 28.992855416819705,
  28.927322290739461, 28.861712926051933, 28.796021804011673,
  28.730242097763966, 28.664366980454098, 28.598389625227352,
  28.532303205229006, 28.466100893604349, 28.399775863498665,
  28.333321288057238, 28.266730340425358, 28.199999523266641, 28.1331386573181,
  28.066160892835079, 27.999079380072931, 27.931907269287006,
  27.864657710732644, 27.797343854665197, 27.729978851340015,
  27.662575851012445, 27.595148003937844, 27.527704226578308,
  27.460236500223047, 27.392732572367997, 27.325180190509112,
  27.257567102142357, 27.189881054763664, 27.122109795869005,
  27.054241072954319, 26.986262633515569, 26.918162225048704,
  26.849930420858815, 26.781569097487608, 26.713082957285906,
  26.644476702604557, 26.575755035794398, 26.506922659206257,
  26.437984275190988, 26.368944586099417, 26.299808294282386,
  26.23058010209073, 26.161265863943704, 26.091876042534221,
  26.022422252623592, 25.952916108973145, 25.883369226344204,
  25.813793219498088, 25.74419970319612, 25.674600292199624, 25.60500660126992,
  25.535430245168335, 25.465876709628706, 25.396326964274969,
  25.326755849703574, 25.257138206510966, 25.187448875293608,
  25.11766269664794, 25.047754511170421, 24.977699159457497, 24.90747148210562,
  24.837046319711245, 24.766405356697497, 24.695557652794232,
  24.624519111557984, 24.553305636545286, 24.481933131312672,
  24.410417499416674, 24.338774644413828, 24.267020469860665,
  24.195170879313721, 24.123241776329529, 24.051238759981871,
  23.979126211413512, 23.906858207284468, 23.834388824254749,
  23.761672138984377, 23.688662228133357, 23.615313168361705,
  23.541579036329434, 23.46741390869656, 23.392771862123098,
  23.317624823378257, 23.242016119668051, 23.166006928307695, 23.0896584266124,
  23.01303179189739, 22.936188201477869, 22.859188832669062,
  22.782094862786181, 22.704967469144435, 22.627867829059046,
  22.550841042463968, 22.473867899768127, 22.39691311399918,
  22.319941398184792, 22.24291746535263, 22.165806028530351,
  22.088571800745619, 22.011179495026095, 21.933593824399445,
  21.855779501893331, 21.777713035419026, 21.699418112422279,
  21.620930215232441, 21.542284826178875, 21.46351742759094,
  21.384663501797991, 21.305758531129392, 21.226837997914494,
  21.147937384482663, 21.069092173163256, 20.990324750751991,
  20.911605121910029, 20.832890195764882, 20.754136881444076,
  20.675302088075121, 20.596342724785533, 20.517215700702838,
  20.437877924954542, 20.35828630666817, 20.278397754971241, 20.19818563726691,
  20.117689154060937, 20.036963964134717, 19.95606572626966,
  19.875050099247165, 19.793972741848631, 19.712889312855463,
  19.631855471049061, 19.550926875210831, 19.470159184122171,
  19.389591130060623, 19.309193739288297, 19.228921111563437,
  19.148727346644286, 19.068566544289094, 18.9883928042561, 18.908160226303558,
  18.8278229101897, 18.747334955672777, 18.66665046251104, 18.585734286326563,
  18.504594306196807, 18.423249157063054, 18.3417174738666, 18.260017891548731,
  18.178169045050744, 18.096189569313932, 18.014098099279579,
  17.93191326988898, 17.849653716083427, 17.767337401078663, 17.68497960118825,
  17.602594921000193, 17.520197965102511, 17.437803338083221,
  17.355425644530321, 17.27307948903184, 17.190779476175774,
  17.108540210550146, 17.026376296742971, 16.944295597657806,
  16.862279009460462, 16.78030068663228, 16.698334783654619,
  16.616355455008836, 16.534336855176278, 16.452253138638298,
  16.370078459876254, 16.287786973371492, 16.205352833605374,
  16.122759111086413, 16.040024540431823, 15.957176772285971,
  15.874243457293232, 15.79125224609799, 15.708230789344608, 15.62520673767747,
  15.542207741740945, 15.459261452179412, 15.376395519637242,
  15.29362544882661, 15.210918160730825, 15.128228430401004,
  15.045511032888259, 14.9627207432437, 14.879812336518443, 14.796740587763589,
  14.713460272030252, 14.629926164369545, 14.546093039832579,
  14.461933217682665, 14.377489194031876, 14.292821009204504,
  14.207988703524835, 14.12305231731715, 14.038071890905742,
  13.953107464614884, 13.868219078768865, 13.78346677369197,
  13.698910589708483, 13.614596436680866, 13.530513702624242,
  13.446637645091922, 13.362943521637209, 13.279406589813407,
  13.196002107173825, 13.112705331271759, 13.029491519660514,
  12.946335929893397, 12.863213819523711, 12.780093984249866,
  12.696919372350656, 12.61362647024999, 12.530151764371771,
  12.446431741139904, 12.362402886978298, 12.278001688310846,
  12.193164631561457, 12.107828203154035, 12.021928889512482,
  11.935437274071639, 11.84846032831004, 11.761139120717177,
  11.673614719782531, 11.586028193995588, 11.498520611845835,
  11.411233041822747, 11.324306552415809, 11.237882212114506,
  11.152101089408323, 11.067057323469552, 10.982657336201671,
  10.898760620190973, 10.815226668023744, 10.731914972286273,
  10.648685025564847, 10.565396320445744, 10.481908349515257,
  10.39808060535967, 10.313772580565271, 10.228885729912832,
  10.143489356961103, 10.057694727463304, 9.9716131071726739, 9.88535576184245,
  9.7990339572258662, 9.7127589590761634, 9.626642033146565, 9.54079444519031,
  9.4553274609606355, 9.3703178655041, 9.2857045210405769, 9.2013918090832352,
  9.1172841111452669, 9.0332858087398549, 8.9493012833801817, 8.86523491657944,
  8.7809910898508026, 8.6964741847074567, 8.6115885826625878,
  8.5262574127855419, 8.44047879437032, 8.3542695942670662, 8.2676466793259511,
  8.180626916397129, 8.0932271723307618, 8.005464313977015, 7.9173552081860352,
  7.8289167218079871, 7.7401657216930309, 7.6511291877497261,
  7.5618745521202486, 7.472479360005158, 7.3830211566050314,
  7.2935774871204408, 7.204225896751959, 7.1150439307001632,
  7.0261091341656137, 6.9374990523488869, 6.8492912304505564,
  6.7615432389550509, 6.6742327494822309, 6.587317458935793,
  6.5007550642194518, 6.4145032622369165, 6.3285197498918961,
  6.2427622240881036, 6.1571883817292372, 6.0717559197190107,
  5.9864225349611333, 5.9011354536720422, 5.8158000193190915,
  5.7303111046823441, 5.6445635825418821, 5.5584523256777789,
  5.4718722068701116, 5.38471809889896, 5.2968848745443866, 5.2082674065864731,
  5.1187605678052952, 5.0283132368617638, 4.9370903159401589,
  4.8453107131055866, 4.7531933364231742, 4.66095709395804, 4.5688208937753032,
  4.4770036439400913, 4.3857242525175089, 4.2952016275726832,
  4.2056546771707337, 4.1172291580200859, 4.02977822140238, 3.9430818672425292,
  3.8569200954654672, 3.7710729059961206, 3.6853202987594162,
  3.5994422736802871, 3.5132188306836478, 3.4264299696944316,
  3.338855690637565, 3.250338324757005, 3.1609695285728545, 3.0709032899242388,
  2.9802935966503012, 2.8892944365901791, 2.7980597975830106,
  2.706743667467939, 2.61550003408409, 2.524482885270606, 2.4338462088666262,
  2.3437597650296378, 2.2544564031905479, 2.1661847450985974,
  2.079193412503046, 1.9937310271531485, 1.910046210798158, 1.8283875851873339,
  1.749003772069919, 1.6721433931951726, 1.5980550703123488, 1.526705471876237,
  1.4569334531636782, 1.3872959161569844, 1.3163497628384835,
  1.2426518951904972, 1.1647592151953488, 1.081228624835366,
  0.99061702609285951, 0.89148132095015764, 0.78237841138958275,
  0.662510610284993, 0.53366187407662458, 0.39826157009633417,
  0.2587390656760058, 0.11752372814751466, -0.022955075157263916,
  -0.16026797690644556, -0.29198560976816523, -0.41567860641055709,
  -0.52891759950173611, -0.62998618589637556, -0.72001981919559022,
  -0.80086691718716252, -0.87437589765889179, -0.94239517839855957,
  -1.0067731771939539, -1.0693583118328625, -1.1319990001030684,
  -1.1965436597923684, -1.264840708688546, -1.3383072126098157,
  -1.4166348294959472, -1.4990838653170555, -1.5849146260432736,
  -1.673387417644717, -1.7637625460915065, -1.8553003173537632,
  -1.9472610374016019, -2.0389050122051571, -2.129492547734543,
  -2.2184590303686957, -2.3059401681218779, -2.3922467494171897,
  -2.4776895626777518, -2.5625793963266652, -2.6472270387870376,
  -2.7319432784819759, -2.8170389038345824, -2.9028247032679761,
  -2.9896114652052592, -3.0776190327566639, -3.166703467780891,
  -3.2566298868237453, -3.3471634064310489, -3.4380691431486068,
  -3.5291122135222288, -3.6200577340977249, -3.7106708214208997,
  -3.8007165920375763, -3.8899601624935585, -3.9782402252596216,
  -4.0656897765064288, -4.1525153883296131, -4.2389236328248279,
  -4.3251210820877075, -4.4113143082138926, -4.4977098832990228,
  -4.5845143794387324, -4.6719343687286754, -4.7601764232644843,
  -4.8493771571253355, -4.9393933523245224, -5.0300118328588548,
  -5.1210194227251593, -5.2122029459202475, -5.3033492264409352,
  -5.3942450882840367, -5.4846773554463635, -5.574432851924743,
  -5.6632984017159851, -5.7511313853008161, -5.8380714090956305,
  -5.9243286360007374, -6.0101132289164658, -6.0956353507431258,
  -6.1811051643810346, -6.2667328327305079, -6.3527285186918565,
  -6.4393023851654085, -6.5266645950514741, -6.6149546720299508,
  -6.7040295828990271, -6.7936756552364566, -6.883679216620008,
  -6.9738265946274351, -7.0639041168364951, -7.1536981108249451,
  -7.2429949041705379, -7.3315808244510441, -7.4192421992442146,
  -7.5058294884737053, -7.591449681446778, -7.6762738998165991,
  -7.7604732652363513, -7.844218899359201, -7.9276819238383176,
  -8.0110334603268747, -8.0944446304780353, -8.1780865559449829,
  -8.2621303583808832, -8.34670177353739, -8.4317449935600628,
  -8.51715882469293, -8.6028420731800352, -8.6886935452654086,
  -8.7746120471930844, -8.8604963852070941, -8.9462453655514675,
  -9.0317577944702521, -9.11693247820747, -9.2017014100296812,
  -9.286129331293516, -9.370314170378137, -9.4543538556627134,
  -9.5383463155264057, -9.6223894783483725, -9.706581272507778,
  -9.7910196263837772, -9.8758024683555448, -9.9610277268022358,
  -10.046767623495265, -10.132991553775032, -10.219643206374178,
  -10.306666270025364, -10.394004433461232, -10.481601385414427,
  -10.569400814617598, -10.657346409803392, -10.74538185970445,
  -10.833450853053433, -10.921485019619411, -11.009367753317177,
  -11.096970389097955, -11.18416426191296, -11.270820706713424,
  -11.356811058450566, -11.442006652075605, -11.526278822539766,
  -11.609498904794261, -11.691538233790325, -11.772336648630368,
  -11.852108005021604, -11.931134662822451, -12.009698981891324,
  -12.088083322086652, -12.166570043266848, -12.245441505290334,
  -12.324980068015526, -12.40546809130084, -12.487187935004703,
  -12.570339401786168, -12.654792065506786, -12.740332942828742,
  -12.826749050414202, -12.91382740492536, -13.001355023024384,
  -13.089118921373457, -13.176906116634751, -13.264503625470439,
  -13.351698464542713, -13.43831761275459, -13.524347897972495,
  -13.609816110303706, -13.694749039855493, -13.779173476735146,
  -13.863116211049938, -13.946604032907148, -14.029663732414051,
  -14.112322099677922, -14.194605924806046, -14.276551712000229,
  -14.358234821840398, -14.439740329001008, -14.521153308156515,
  -14.602558833981387, -14.684041981150079, -14.765687824337048,
  -14.847581438216752, -14.929807897463645, -15.012452276752198,
  -15.095570821362895, -15.179104459000357, -15.262965287975232,
  -15.347065406598162, -15.431316913179808, -15.515631906030812,
  -15.599922483461823, -15.684100743783485, -15.768078785306454,
  -15.851768706341369, -15.935107740304112, -16.018133661031449,
  -16.100909377465378, -16.1834977985479, -16.265961833221013,
  -16.348364390426724, -16.430768379107025, -16.513236708203916,
  -16.5958322866594, -16.678618023415471, -16.761634202795417,
  -16.844830610647644, -16.928134408201835, -17.011472756687677,
  -17.094772817334853, -17.177961751373054, -17.260966720031963,
  -17.343714884541264, -17.426133406130646, -17.50814944602979,
  -17.589721325180314, -17.670932003371533, -17.7518956001047,
  -17.832726234881061, -17.91353802720187, -17.994445096568377,
  -18.075561562481838, -18.157001544443492, -18.238879161954596,
  -18.321308534516405, -18.4043549326794, -18.487888231191004,
  -18.571729455847866, -18.655699632446641, -18.739619786783969,
  -18.823310944656509, -18.906594131860903, -18.989290374193804,
  -19.071220697451867, -19.152206127431729, -19.232123173125004,
  -19.311070276303102, -19.3892013619324, -19.466670354979282,
  -19.543631180410124, -19.620237763191309, -19.69664402828921,
  -19.773003900670204, -19.849471305300675, -19.926200167146998,
  -20.003317299803424, -20.080841071375641, -20.158762738597211,
  -20.2370735582017, -20.315764786922657, -20.394827681493645,
  -20.474253498648228, -20.554033495119953, -20.634158927642392,
  -20.714621052949095, -20.795392444467655, -20.876370942401763,
  -20.957435703649143, -21.03846588510752, -21.119340643674605,
  -21.19993913624813, -21.280140519725812, -21.359823951005371,
  -21.43886858698453, -21.517153584561008, -21.59460109260764,
  -21.671305227897715, -21.747403099179635, -21.823031815201812,
  -21.898328484712653, -21.973430216460564, -22.048474119193955,
  -22.123597301661228, -22.198936872610791, -22.274629940791051,
  -22.350775929515986, -22.427323520361814, -22.5041837094703,
  -22.581267492983233, -22.658485867042383, -22.735749827789533,
  -22.812970371366458, -22.890058493914928, -22.966925191576731,
  -23.043481460493634, -23.119653495004403, -23.195428282235742,
  -23.270808007511327, -23.345794856154857, -23.420391013490011,
  -23.494598664840485, -23.568419995529958, -23.641857190882117,
  -23.714912436220654, -23.787587916869256, -23.859892891951578,
  -23.931864915791156, -24.0035486165115, -24.07498862223612,
  -24.146229561088521, -24.217316061192214, -24.288292750670706,
  -24.3592042576475, -24.430095210246115, -24.501010236590048,
  -24.57197862886154, -24.642968335477715, -24.713931968914412,
  -24.784822141647485, -24.855591466152774, -24.926192554906134,
  -24.996578020383403, -25.066700475060429, -25.136512531413064,
  -25.205966801917146, -25.275037032874188, -25.343781505888348,
  -25.412279636389442, -25.4806108398073, -25.548854531571738,
  -25.617090127112586, -25.685397041859659, -25.753854691242779,
  -25.822542490691774, -25.891539855636463, -25.960897099443084,
  -26.030548127223518, -26.100397742026058, -26.170350746898997,
  -26.240311944890628, -26.310186139049243, -26.379878132423134,
  -26.449292728060588, -26.518334729009915, -26.586908938319382,
  -26.654955325818054, -26.722554528457994, -26.789822349972034,
  -26.856874594093014, -26.923827064553748, -26.990795565087083,
  -27.057895899425841, -27.125243871302853, -27.192955284450964,
  -27.261145942602983, -27.329880889127232, -27.399022125933893,
  -27.468380894568618, -27.537768436577078, -27.606995993504903,
  -27.675874806897767, -27.744216118301317, -27.811831169261207,
  -27.878531201323096, -27.944127456032628, -28.008505712216376,
  -28.071849897824528, -28.1344184780882, -28.196469918238506,
  -28.258262683506551, -28.320055239123462, -28.382106050320342,
  -28.444673582328313, -28.508016300378483, -28.572392669701959,
  -28.637981240139098, -28.704640899967135, -28.77215062207252,
  -28.840289379341709, -28.908836144661155, -28.977569890917323,
  -29.046269590996658, -29.114714217785622, -29.182682744170663,
  -29.249954143038238, -29.316363399175675, -29.381969544973785,
  -29.446887624724269, -29.511232682718816, -29.57511976324912,
  -29.638663910606883, -29.7019801690838, -29.765183582971563,
  -29.828389196561865, -29.8917120541464, -29.955238958432236,
  -30.018943745787887, -30.082772010997225, -30.146669348844132,
  -30.210581354112477, -30.274453621586147, -30.338231746049015,
  -30.401861322284958, -30.465287945077851, -30.528457209211567,
  -30.591329092628133, -30.653921105902111, -30.716265142766211,
  -30.778393096953149, -30.840336862195624, -30.902128332226365,
  -30.963799400778068, -31.025381961583452, -31.086907908375224,
  -31.148409134886094, -31.209909884229269, -31.271403797039923,
  -31.332876863333716, -31.394315073126322, -31.455704416433392,
  -31.517030883270607, -31.578280463653623, -31.639439147598111,
  -31.700492925119732, -31.761427786234151, -31.822235142928932,
  -31.882928095079212, -31.943525164532023, -32.004044873134404,
  -32.064505742733381, -32.124926295176, -32.185325052309288,
  -32.24572053598029, -32.306131268036026, -32.366575770323529,
  -32.427058481930608, -32.487527510908073, -32.5479168825475,
  -32.608160622140467, -32.668192754978541, -32.727947306353315,
  -32.787358301556353, -32.846359765879228, -32.904885724613521,
  -32.962870203050805, -33.020275957744175, -33.077180670292748,
  -33.133690753557175, -33.189912620398111, -33.24595268367618,
  -33.301917356252041, -33.357913050986348, -33.414046180739732,
  -33.470423158372839, -33.527150396746322, -33.584299862966837,
  -33.641805741125104, -33.699567769557852, -33.7574856866018,
  -33.815459230593667, -33.873388139870194, -33.931172152768106,
  -33.988711007624126, -34.045904442774976, -34.102652196557379,
  -34.158885593987456, -34.214662306798836, -34.270071593404531,
  -34.325202712217575, -34.380144921650988, -34.43498748011779,
  -34.489819646031, -34.544730677803649, -34.599809833848745,
  -34.655146372579317, -34.710793139527659, -34.766657328703069,
  -34.822609721234123, -34.878521098249387, -34.93426224087743,
  -34.989703930246833, -35.044716947486144, -35.099172073723949,
  -35.152940090088812, -35.2058917777093, -35.257927698827416,
  -35.309067540138919, -35.359360769453005, -35.408856854578872,
  -35.457605263325718, -35.505655463502741, -35.553056922919133,
  -35.5998591093841, -35.646111490706836, -35.691863534696523,
  -35.737171704572908, -35.7821204451978, -35.82680119684354,
  -35.871305399782493, -35.915724494286991, -35.960149920629391,
  -36.004673119082042, -36.049385529917288, -36.094378593407484,
  -36.139743749824959, -36.185542517852582, -36.231716729815183,
  -36.278178296448104, -36.324839128486666, -36.37161113666621,
  -36.418406231722074, -36.46513632438959, -36.511713325404088,
  -36.55804914550091, -36.604055695415376, -36.649644885882836,
  -36.694728627638625, -36.739218831418064, -36.783027407956496,
  -36.826066267989248, -36.868247322251662, -36.909482481479074 };

static const double dv1[1001] = { -50.0, -49.9, -49.8, -49.7, -49.6, -49.5,
  -49.4, -49.3, -49.2, -49.1, -49.0, -48.9, -48.8, -48.7, -48.6, -48.5, -48.4,
  -48.3, -48.2, -48.1, -48.0, -47.9, -47.8, -47.7, -47.6, -47.5, -47.4, -47.3,
  -47.2, -47.1, -47.0, -46.9, -46.8, -46.7, -46.6, -46.5, -46.4, -46.3, -46.2,
  -46.1, -46.0, -45.9, -45.8, -45.7, -45.6, -45.5, -45.4, -45.3, -45.2, -45.1,
  -45.0, -44.9, -44.8, -44.7, -44.6, -44.5, -44.4, -44.3, -44.2, -44.1, -44.0,
  -43.9, -43.8, -43.7, -43.6, -43.5, -43.4, -43.3, -43.2, -43.1, -43.0, -42.9,
  -42.8, -42.7, -42.6, -42.5, -42.4, -42.3, -42.2, -42.1, -42.0, -41.9, -41.8,
  -41.7, -41.6, -41.5, -41.4, -41.3, -41.2, -41.1, -41.0, -40.9, -40.8, -40.7,
  -40.6, -40.5, -40.4, -40.3, -40.2, -40.1, -40.0, -39.9, -39.8, -39.7, -39.6,
  -39.5, -39.4, -39.3, -39.2, -39.1, -39.0, -38.9, -38.8, -38.7, -38.6, -38.5,
  -38.4, -38.3, -38.2, -38.1, -38.0, -37.9, -37.8, -37.7, -37.6, -37.5, -37.4,
  -37.3, -37.2, -37.1, -37.0, -36.9, -36.8, -36.7, -36.6, -36.5, -36.4, -36.3,
  -36.2, -36.1, -36.0, -35.9, -35.8, -35.7, -35.6, -35.5, -35.4, -35.3, -35.2,
  -35.1, -35.0, -34.9, -34.8, -34.7, -34.6, -34.5, -34.4, -34.3, -34.2, -34.1,
  -34.0, -33.9, -33.8, -33.7, -33.599999999999994, -33.5, -33.4, -33.3, -33.2,
  -33.099999999999994, -33.0, -32.9, -32.8, -32.7, -32.599999999999994, -32.5,
  -32.4, -32.3, -32.2, -32.099999999999994, -32.0, -31.9, -31.8, -31.7,
  -31.599999999999998, -31.5, -31.4, -31.3, -31.2, -31.099999999999998, -31.0,
  -30.9, -30.799999999999997, -30.7, -30.599999999999998, -30.5, -30.4,
  -30.299999999999997, -30.2, -30.099999999999998, -30.0, -29.9,
  -29.799999999999997, -29.7, -29.599999999999998, -29.5, -29.4,
  -29.299999999999997, -29.2, -29.099999999999998, -29.0, -28.9,
  -28.799999999999997, -28.7, -28.599999999999998, -28.5, -28.4,
  -28.299999999999997, -28.2, -28.099999999999998, -28.0, -27.9,
  -27.799999999999997, -27.7, -27.599999999999998, -27.5, -27.4,
  -27.299999999999997, -27.2, -27.099999999999998, -27.0, -26.9,
  -26.799999999999997, -26.7, -26.599999999999998, -26.5, -26.4,
  -26.299999999999997, -26.2, -26.099999999999998, -26.0, -25.9,
  -25.799999999999997, -25.7, -25.599999999999998, -25.5, -25.4,
  -25.299999999999997, -25.2, -25.099999999999998, -25.0, -24.9,
  -24.799999999999997, -24.7, -24.599999999999998, -24.5, -24.4,
  -24.299999999999997, -24.2, -24.099999999999998, -24.0, -23.9,
  -23.799999999999997, -23.7, -23.599999999999998, -23.5, -23.4,
  -23.299999999999997, -23.2, -23.099999999999998, -23.0, -22.9,
  -22.799999999999997, -22.7, -22.599999999999998, -22.5, -22.4,
  -22.299999999999997, -22.2, -22.099999999999998, -22.0, -21.9,
  -21.799999999999997, -21.7, -21.599999999999998, -21.5, -21.4,
  -21.299999999999997, -21.2, -21.099999999999998, -21.0, -20.9,
  -20.799999999999997, -20.7, -20.599999999999998, -20.5, -20.4,
  -20.299999999999997, -20.2, -20.099999999999998, -20.0, -19.9,
  -19.799999999999997, -19.7, -19.599999999999998, -19.5, -19.4,
  -19.299999999999997, -19.2, -19.099999999999998, -19.0, -18.9,
  -18.799999999999997, -18.7, -18.599999999999998, -18.5, -18.4,
  -18.299999999999997, -18.2, -18.099999999999998, -18.0, -17.9,
  -17.799999999999997, -17.699999999999996, -17.6, -17.5, -17.4,
  -17.299999999999997, -17.199999999999996, -17.1, -17.0, -16.9,
  -16.799999999999997, -16.699999999999996, -16.6, -16.5, -16.4,
  -16.299999999999997, -16.199999999999996, -16.1, -16.0, -15.899999999999999,
  -15.799999999999997, -15.699999999999996, -15.600000000000001, -15.5,
  -15.399999999999999, -15.299999999999997, -15.199999999999996,
  -15.100000000000001, -15.0, -14.899999999999999, -14.799999999999997,
  -14.699999999999996, -14.600000000000001, -14.5, -14.399999999999999,
  -14.299999999999997, -14.199999999999996, -14.100000000000001, -14.0,
  -13.899999999999999, -13.799999999999997, -13.699999999999996,
  -13.600000000000001, -13.5, -13.399999999999999, -13.299999999999997,
  -13.199999999999996, -13.100000000000001, -13.0, -12.899999999999999,
  -12.799999999999997, -12.699999999999996, -12.600000000000001, -12.5,
  -12.399999999999999, -12.299999999999997, -12.199999999999996,
  -12.100000000000001, -12.0, -11.899999999999999, -11.799999999999997,
  -11.699999999999996, -11.599999999999994, -11.5, -11.399999999999999,
  -11.299999999999997, -11.199999999999996, -11.099999999999994, -11.0,
  -10.899999999999999, -10.799999999999997, -10.699999999999996,
  -10.599999999999994, -10.5, -10.399999999999999, -10.299999999999997,
  -10.199999999999996, -10.099999999999994, -10.0, -9.8999999999999986,
  -9.7999999999999972, -9.6999999999999957, -9.5999999999999943, -9.5,
  -9.3999999999999986, -9.2999999999999972, -9.1999999999999957,
  -9.0999999999999943, -9.0, -8.8999999999999986, -8.7999999999999972,
  -8.6999999999999957, -8.5999999999999943, -8.5, -8.3999999999999986,
  -8.2999999999999972, -8.1999999999999957, -8.0999999999999943, -8.0,
  -7.8999999999999986, -7.7999999999999972, -7.6999999999999957,
  -7.5999999999999943, -7.5, -7.3999999999999986, -7.2999999999999972,
  -7.1999999999999957, -7.0999999999999943, -7.0, -6.8999999999999986,
  -6.7999999999999972, -6.6999999999999957, -6.5999999999999943, -6.5,
  -6.3999999999999986, -6.2999999999999972, -6.1999999999999957,
  -6.0999999999999943, -6.0, -5.8999999999999986, -5.7999999999999972,
  -5.6999999999999957, -5.5999999999999943, -5.5, -5.3999999999999986,
  -5.2999999999999972, -5.1999999999999957, -5.0999999999999943, -5.0,
  -4.8999999999999986, -4.7999999999999972, -4.6999999999999957,
  -4.5999999999999943, -4.5, -4.3999999999999986, -4.2999999999999972,
  -4.1999999999999957, -4.0999999999999943, -4.0, -3.8999999999999986,
  -3.7999999999999972, -3.6999999999999957, -3.5999999999999943, -3.5,
  -3.3999999999999986, -3.2999999999999972, -3.1999999999999957,
  -3.0999999999999943, -3.0, -2.8999999999999986, -2.7999999999999972,
  -2.6999999999999957, -2.5999999999999943, -2.5, -2.3999999999999986,
  -2.2999999999999972, -2.1999999999999957, -2.0999999999999943, -2.0,
  -1.8999999999999986, -1.7999999999999972, -1.6999999999999957,
  -1.5999999999999943, -1.5, -1.3999999999999986, -1.2999999999999972,
  -1.1999999999999957, -1.0999999999999943, -1.0, -0.89999999999999858,
  -0.79999999999999716, -0.69999999999999574, -0.59999999999999432, -0.5,
  -0.39999999999999858, -0.29999999999999716, -0.19999999999999574,
  -0.099999999999994316, 0.0, 0.099999999999994316, 0.19999999999999574,
  0.29999999999999716, 0.39999999999999858, 0.5, 0.59999999999999432,
  0.69999999999999574, 0.79999999999999716, 0.89999999999999858, 1.0,
  1.0999999999999943, 1.1999999999999957, 1.2999999999999972,
  1.3999999999999986, 1.5, 1.5999999999999943, 1.6999999999999957,
  1.7999999999999972, 1.8999999999999986, 2.0, 2.0999999999999943,
  2.1999999999999957, 2.2999999999999972, 2.3999999999999986, 2.5,
  2.5999999999999943, 2.6999999999999957, 2.7999999999999972,
  2.8999999999999986, 3.0, 3.0999999999999943, 3.1999999999999957,
  3.2999999999999972, 3.3999999999999986, 3.5, 3.5999999999999943,
  3.6999999999999957, 3.7999999999999972, 3.8999999999999986, 4.0,
  4.0999999999999943, 4.1999999999999957, 4.2999999999999972,
  4.3999999999999986, 4.5, 4.5999999999999943, 4.6999999999999957,
  4.7999999999999972, 4.8999999999999986, 5.0, 5.0999999999999943,
  5.1999999999999957, 5.2999999999999972, 5.3999999999999986, 5.5,
  5.5999999999999943, 5.6999999999999957, 5.7999999999999972,
  5.8999999999999986, 6.0, 6.0999999999999943, 6.1999999999999957,
  6.2999999999999972, 6.3999999999999986, 6.5, 6.5999999999999943,
  6.6999999999999957, 6.7999999999999972, 6.8999999999999986, 7.0,
  7.0999999999999943, 7.1999999999999957, 7.2999999999999972,
  7.3999999999999986, 7.5, 7.5999999999999943, 7.6999999999999957,
  7.7999999999999972, 7.8999999999999986, 8.0, 8.0999999999999943,
  8.1999999999999957, 8.2999999999999972, 8.3999999999999986, 8.5,
  8.5999999999999943, 8.6999999999999957, 8.7999999999999972,
  8.8999999999999986, 9.0, 9.0999999999999943, 9.1999999999999957,
  9.2999999999999972, 9.3999999999999986, 9.5, 9.5999999999999943,
  9.6999999999999957, 9.7999999999999972, 9.8999999999999986, 10.0,
  10.099999999999994, 10.199999999999996, 10.299999999999997,
  10.399999999999999, 10.5, 10.599999999999994, 10.699999999999996,
  10.799999999999997, 10.899999999999999, 11.0, 11.099999999999994,
  11.199999999999996, 11.299999999999997, 11.399999999999999, 11.5,
  11.599999999999994, 11.699999999999996, 11.799999999999997,
  11.899999999999999, 12.0, 12.100000000000001, 12.199999999999996,
  12.299999999999997, 12.399999999999999, 12.5, 12.600000000000001,
  12.699999999999996, 12.799999999999997, 12.899999999999999, 13.0,
  13.100000000000001, 13.199999999999996, 13.299999999999997,
  13.399999999999999, 13.5, 13.600000000000001, 13.699999999999996,
  13.799999999999997, 13.899999999999999, 14.0, 14.100000000000001,
  14.199999999999996, 14.299999999999997, 14.399999999999999, 14.5,
  14.600000000000001, 14.699999999999996, 14.799999999999997,
  14.899999999999999, 15.0, 15.100000000000001, 15.199999999999996,
  15.299999999999997, 15.399999999999999, 15.5, 15.600000000000001,
  15.699999999999996, 15.799999999999997, 15.899999999999999, 16.0, 16.1,
  16.199999999999996, 16.299999999999997, 16.4, 16.5, 16.6, 16.699999999999996,
  16.799999999999997, 16.9, 17.0, 17.1, 17.199999999999996, 17.299999999999997,
  17.4, 17.5, 17.6, 17.699999999999996, 17.799999999999997, 17.9, 18.0,
  18.099999999999998, 18.2, 18.299999999999997, 18.4, 18.5, 18.599999999999998,
  18.7, 18.799999999999997, 18.9, 19.0, 19.099999999999998, 19.2,
  19.299999999999997, 19.4, 19.5, 19.599999999999998, 19.7, 19.799999999999997,
  19.9, 20.0, 20.099999999999998, 20.2, 20.299999999999997, 20.4, 20.5,
  20.599999999999998, 20.7, 20.799999999999997, 20.9, 21.0, 21.099999999999998,
  21.2, 21.299999999999997, 21.4, 21.5, 21.599999999999998, 21.7,
  21.799999999999997, 21.9, 22.0, 22.099999999999998, 22.2, 22.299999999999997,
  22.4, 22.5, 22.599999999999998, 22.7, 22.799999999999997, 22.9, 23.0,
  23.099999999999998, 23.2, 23.299999999999997, 23.4, 23.5, 23.599999999999998,
  23.7, 23.799999999999997, 23.9, 24.0, 24.099999999999998, 24.2,
  24.299999999999997, 24.4, 24.5, 24.599999999999998, 24.7, 24.799999999999997,
  24.9, 25.0, 25.099999999999998, 25.2, 25.299999999999997, 25.4, 25.5,
  25.599999999999998, 25.7, 25.799999999999997, 25.9, 26.0, 26.099999999999998,
  26.2, 26.299999999999997, 26.4, 26.5, 26.599999999999998, 26.7,
  26.799999999999997, 26.9, 27.0, 27.099999999999998, 27.2, 27.299999999999997,
  27.4, 27.5, 27.599999999999998, 27.7, 27.799999999999997, 27.9, 28.0,
  28.099999999999998, 28.2, 28.299999999999997, 28.4, 28.5, 28.599999999999998,
  28.7, 28.799999999999997, 28.9, 29.0, 29.099999999999998, 29.2,
  29.299999999999997, 29.4, 29.5, 29.599999999999998, 29.7, 29.799999999999997,
  29.9, 30.0, 30.099999999999998, 30.2, 30.299999999999997, 30.4, 30.5,
  30.599999999999998, 30.7, 30.799999999999997, 30.9, 31.0, 31.099999999999998,
  31.2, 31.3, 31.4, 31.5, 31.599999999999998, 31.7, 31.8, 31.9, 32.0,
  32.099999999999994, 32.2, 32.3, 32.4, 32.5, 32.599999999999994, 32.7, 32.8,
  32.9, 33.0, 33.099999999999994, 33.2, 33.3, 33.4, 33.5, 33.599999999999994,
  33.7, 33.8, 33.9, 34.0, 34.1, 34.2, 34.3, 34.4, 34.5, 34.6, 34.7, 34.8, 34.9,
  35.0, 35.1, 35.2, 35.3, 35.4, 35.5, 35.6, 35.7, 35.8, 35.9, 36.0, 36.1, 36.2,
  36.3, 36.4, 36.5, 36.6, 36.7, 36.8, 36.9, 37.0, 37.1, 37.2, 37.3, 37.4, 37.5,
  37.6, 37.7, 37.8, 37.9, 38.0, 38.1, 38.2, 38.3, 38.4, 38.5, 38.6, 38.7, 38.8,
  38.9, 39.0, 39.1, 39.2, 39.3, 39.4, 39.5, 39.6, 39.7, 39.8, 39.9, 40.0, 40.1,
  40.2, 40.3, 40.4, 40.5, 40.6, 40.7, 40.8, 40.9, 41.0, 41.1, 41.2, 41.3, 41.4,
  41.5, 41.6, 41.7, 41.8, 41.9, 42.0, 42.1, 42.2, 42.3, 42.4, 42.5, 42.6, 42.7,
  42.8, 42.9, 43.0, 43.1, 43.2, 43.3, 43.4, 43.5, 43.6, 43.7, 43.8, 43.9, 44.0,
  44.1, 44.2, 44.3, 44.4, 44.5, 44.6, 44.7, 44.8, 44.9, 45.0, 45.1, 45.2, 45.3,
  45.4, 45.5, 45.6, 45.7, 45.8, 45.9, 46.0, 46.1, 46.2, 46.3, 46.4, 46.5, 46.6,
  46.7, 46.8, 46.9, 47.0, 47.1, 47.2, 47.3, 47.4, 47.5, 47.6, 47.7, 47.8, 47.9,
  48.0, 48.1, 48.2, 48.3, 48.4, 48.5, 48.6, 48.7, 48.8, 48.9, 49.0, 49.1, 49.2,
  49.3, 49.4, 49.5, 49.6, 49.7, 49.8, 49.9, 50.0 };

// Variable Definitions
//static coder::comm::RaisedCosineReceiveFilter b_rxFilter1;
//static boolean_T b_rxFilter1_not_empty;

// Function Declarations
static double optimize_sin(const emxArray_real_T *t, const emxArray_real_T *s2, const double bounds[2], double f0);

// Function Definitions
//
// Arguments    : const emxArray_real_T *t
//                const emxArray_real_T *s2
//                const double bounds[2]
//                double f0
// Return Type  : double
//
static double optimize_sin(const emxArray_real_T *t, const emxArray_real_T *s2, const double bounds[2], double f0)
{
  emxArray_boolean_T *r;
  emxArray_boolean_T *r1;
  emxArray_int32_T *r2;
  emxArray_real_T *a;
  emxArray_real_T *idx;
  emxArray_real_T *y;
  emxArray_real_T *y2;
  double FFnu[50];
  double dErr;
  double dnu;
  double err2;
  double f_opt;
  double nu;
  double ph_opt;
  int b_loop_ub;
  int b_loop_ub_tmp;
  int c_loop_ub;
  int d_loop_ub;
  int e_loop_ub;
  int f_loop_ub;
  int g_loop_ub;
  int i;
  int i1;
  int i2;
  int loop_ub;
  int loop_ub_tmp;
  int nx;
  dErr = 1.0;
  err2 = 0.0;
  f_opt = f0;
  dnu = f0 * t->data[0];
  if (dnu < 0.0) {
    ph_opt = std::ceil(dnu);
  } else {
    ph_opt = std::floor(dnu);
  }

  ph_opt = 0.2013579207903308 - 6.2831853071795862 * (dnu - ph_opt);
  if (ph_opt < 0.0) {
    ph_opt += 6.2831853071795862;
  }

  loop_ub = t->size[0];
  if (1.0 > bounds[0]) {
    b_loop_ub = 0;
  } else {
    b_loop_ub = static_cast<int>(bounds[0]);
  }

  if (bounds[1] > s2->size[0]) {
    i = 0;
    i1 = 0;
  } else {
    i = static_cast<int>(bounds[1]) - 1;
    i1 = s2->size[0];
  }

  loop_ub_tmp = i1 - i;
  c_loop_ub = t->size[0];
  if (1.0 > bounds[0]) {
    d_loop_ub = 0;
  } else {
    d_loop_ub = static_cast<int>(bounds[0]);
  }

  if (bounds[1] > s2->size[0]) {
    i1 = 0;
    i2 = 0;
  } else {
    i1 = static_cast<int>(bounds[1]) - 1;
    i2 = s2->size[0];
  }

  b_loop_ub_tmp = i2 - i1;
  e_loop_ub = t->size[0];
  emxInit_real_T(&idx, 2);
  if (s2->size[0] < 1) {
    idx->size[0] = 1;
    idx->size[1] = 0;
  } else {
    i2 = idx->size[0] * idx->size[1];
    idx->size[0] = 1;
    idx->size[1] = static_cast<int>(static_cast<double>(s2->size[0]) - 1.0) + 1;
    emxEnsureCapacity_real_T(idx, i2);
    f_loop_ub = static_cast<int>(static_cast<double>(s2->size[0]) - 1.0);
    for (i2 = 0; i2 <= f_loop_ub; i2++) {
      idx->data[i2] = static_cast<double>(i2) + 1.0;
    }
  }

  f_loop_ub = idx->size[0] * idx->size[1];
  g_loop_ub = idx->size[0] * idx->size[1];
  emxInit_boolean_T(&r, 2);
  emxInit_boolean_T(&r1, 2);
  emxInit_int32_T(&r2, 2);
  emxInit_real_T(&y2, 1);
  emxInit_real_T(&y, 1);
  emxInit_real_T(&a, 1);
  while (dErr > 0.01) {
    int b_i;
    int k;
    dErr = 6.2831853071795862 * (f_opt - 50.0);
    dnu = 6.2831853071795862 * ((f_opt + 50.0) - (f_opt - 50.0)) / 50.0;
    for (b_i = 0; b_i < 50; b_i++) {
      nu = dErr + dnu * ((static_cast<double>(b_i) + 1.0) - 1.0);
      i2 = y2->size[0];
      y2->size[0] = t->size[0];
      emxEnsureCapacity_real_T(y2, i2);
      for (i2 = 0; i2 < loop_ub; i2++) {
        y2->data[i2] = nu * t->data[i2] + ph_opt;
        y2->data[i2] = std::sin(y2->data[i2]);
        y2->data[i2] *= 0.8;
      }

//      nx = y2->size[0];
//      for (k = 0; k < nx; k++) {
//        y2->data[k] = std::sin(y2->data[k]);
//      }

//      nx = y2->size[0];
//      for (i2 = 0; i2 < nx; i2++) {
//        y2->data[i2] *= 0.8;
//      }

      i2 = a->size[0];
      a->size[0] = b_loop_ub;
      emxEnsureCapacity_real_T(a, i2);
      for (i2 = 0; i2 < b_loop_ub; i2++) {
        a->data[i2] = s2->data[i2] - y2->data[i2];
        a->data[i2] = rt_powd_snf(a->data[i2], 2.0);
      }

//      i2 = y->size[0];
//      y->size[0] = a->size[0];
//      emxEnsureCapacity_real_T(y, i2);
//      nx = a->size[0];
//      for (k = 0; k < nx; k++) {
//        y->data[k] = rt_powd_snf(a->data[k], 2.0);
//      }

      nx = a->size[0];
      if (a->size[0] == 0) {
        nu = 0.0;
      } else {
        nu = a->data[0];
        for (k = 2; k <= nx; k++) {
          nu += a->data[k - 1];
        }
      }

      FFnu[b_i] = nu;
      if (bounds[1] > y2->size[0]) {
        i2 = 1;
      } else {
        i2 = static_cast<int>(bounds[1]);
      }

      nx = a->size[0];
      a->size[0] = loop_ub_tmp;
      emxEnsureCapacity_real_T(a, nx);
      for (nx = 0; nx < loop_ub_tmp; nx++) {
        a->data[nx] = s2->data[i + nx] - y2->data[(i2 + nx) - 1];
        a->data[nx] = rt_powd_snf(a->data[nx], 2.0);
      }

//      i2 = y->size[0];
//      y->size[0] = a->size[0];
//      emxEnsureCapacity_real_T(y, i2);
//      nx = a->size[0];
//      for (k = 0; k < nx; k++) {
//        y->data[k] = rt_powd_snf(a->data[k], 2.0);
//      }

      nx = a->size[0];
      if (a->size[0] == 0) {
        nu = 0.0;
      } else {
        nu = a->data[0];
        for (k = 2; k <= nx; k++) {
          nu += a->data[k - 1];
        }
      }

      FFnu[b_i] += nu;
    }

    coder::internal::minimum(FFnu, &nu, &nx);
    f_opt = (dErr + dnu * (absolute_min(static_cast<double>(nx), FFnu) - 1.0)) /
      2.0 / 3.1415926535897931;
    dErr = ((ph_opt + 3.1415926535897931) - (ph_opt - 3.1415926535897931)) /
      50.0;
    dnu = 6.2831853071795862 * f_opt;
    for (b_i = 0; b_i < 50; b_i++) {
      nu = (ph_opt - 3.1415926535897931) + dErr * ((static_cast<double>(b_i) +
        1.0) - 1.0);
      i2 = y2->size[0];
      y2->size[0] = t->size[0];
      emxEnsureCapacity_real_T(y2, i2);
      for (i2 = 0; i2 < c_loop_ub; i2++) {
        y2->data[i2] = dnu * t->data[i2] + nu;
        y2->data[i2] = std::sin(y2->data[i2]);
        y2->data[i2] *= 0.8;
      }

//      nx = y2->size[0];
//      for (k = 0; k < nx; k++) {
//        y2->data[k] = std::sin(y2->data[k]);
//      }

//      nx = y2->size[0];
//      for (i2 = 0; i2 < nx; i2++) {
//        y2->data[i2] *= 0.8;
//      }

      i2 = a->size[0];
      a->size[0] = d_loop_ub;
      emxEnsureCapacity_real_T(a, i2);
      for (i2 = 0; i2 < d_loop_ub; i2++) {
        a->data[i2] = s2->data[i2] - y2->data[i2];
        a->data[i2] = rt_powd_snf(a->data[i2], 2.0);
      }

//      i2 = y->size[0];
//      y->size[0] = a->size[0];
//      emxEnsureCapacity_real_T(y, i2);
//      nx = a->size[0];
//      for (k = 0; k < nx; k++) {
//        y->data[k] = rt_powd_snf(a->data[k], 2.0);
//      }

      nx = a->size[0];
      if (a->size[0] == 0) {
        nu = 0.0;
      } else {
        nu = a->data[0];
        for (k = 2; k <= nx; k++) {
          nu += a->data[k - 1];
        }
      }

      FFnu[b_i] = nu;
      if (bounds[1] > y2->size[0]) {
        i2 = 1;
      } else {
        i2 = static_cast<int>(bounds[1]);
      }

      nx = a->size[0];
      a->size[0] = b_loop_ub_tmp;
      emxEnsureCapacity_real_T(a, nx);
      for (nx = 0; nx < b_loop_ub_tmp; nx++) {
        a->data[nx] = s2->data[i1 + nx] - y2->data[(i2 + nx) - 1];
        a->data[nx] = rt_powd_snf(a->data[nx], 2.0);
      }

//      i2 = y->size[0];
//      y->size[0] = a->size[0];
//      emxEnsureCapacity_real_T(y, i2);
//      nx = a->size[0];
//      for (k = 0; k < nx; k++) {
//        y->data[k] = rt_powd_snf(a->data[k], 2.0);
//      }

      nx = a->size[0];
      if (a->size[0] == 0) {
        nu = 0.0;
      } else {
        nu = a->data[0];
        for (k = 2; k <= nx; k++) {
          nu += a->data[k - 1];
        }
      }

      FFnu[b_i] += nu;
    }

    coder::internal::minimum(FFnu, &nu, &nx);
    ph_opt = (ph_opt - 3.1415926535897931) + dErr * (absolute_min(static_cast<
      double>(nx), FFnu) - 1.0);
    i2 = y->size[0];
    y->size[0] = t->size[0];
    emxEnsureCapacity_real_T(y, i2);
    for (i2 = 0; i2 < e_loop_ub; i2++) {
      y->data[i2] = dnu * t->data[i2] + ph_opt;
      y->data[i2] = std::sin(y->data[i2]);
      y->data[i2] *= 0.8;
    }

//    nx = y->size[0];
//    for (k = 0; k < nx; k++) {
//      y->data[k] = std::sin(y->data[k]);
//    }

//    nx = y->size[0];
//    for (i2 = 0; i2 < nx; i2++) {
//      y->data[i2] *= 0.8;
//    }

    dnu = err2;
    i2 = r->size[0] * r->size[1];
    r->size[0] = 1;
    r->size[1] = idx->size[1];
    emxEnsureCapacity_boolean_T(r, i2);
    for (i2 = 0; i2 < f_loop_ub; i2++) {
      r->data[i2] = (idx->data[i2] <= bounds[0]);
    }

    int two_preamble_size = bounds[0] + (s2->size[0]-(bounds[1]-1));
    for(int i = 0; i <= two_preamble_size; i++){

    }

    i2 = r1->size[0] * r1->size[1];
    r1->size[0] = 1;
    r1->size[1] = idx->size[1];
    emxEnsureCapacity_boolean_T(r1, i2);
    for (i2 = 0; i2 < g_loop_ub; i2++) {
      r1->data[i2] = (idx->data[i2] >= bounds[1]);
    }

    k = r->size[1] - 1;
    nx = 0;
    for (b_i = 0; b_i <= k; b_i++) {
      if (r->data[b_i] || r1->data[b_i]) {
        nx++;
      }
    }

    i2 = r2->size[0] * r2->size[1];
    r2->size[0] = 1;
    r2->size[1] = nx;
    emxEnsureCapacity_int32_T(r2, i2);
    nx = 0;
    for (b_i = 0; b_i <= k; b_i++) {
      if (r->data[b_i] || r1->data[b_i]) {
        r2->data[nx] = b_i + 1;
        nx++;
      }
    }

    i2 = a->size[0];
    a->size[0] = r2->size[1];
    emxEnsureCapacity_real_T(a, i2);
    nx = r2->size[1];
    for (i2 = 0; i2 < nx; i2++) {
      a->data[i2] = y->data[r2->data[i2] - 1] - s2->data[r2->data[i2] - 1];
    }

    i2 = y->size[0];
    y->size[0] = a->size[0];
    emxEnsureCapacity_real_T(y, i2);
    nx = a->size[0];
    for (k = 0; k < nx; k++) {
      y->data[k] = rt_powd_snf(a->data[k], 2.0);
    }

    nx = y->size[0];
    if (y->size[0] == 0) {
      err2 = 0.0;
    } else {
      err2 = y->data[0];
      for (k = 2; k <= nx; k++) {
        err2 += y->data[k - 1];
      }
    }

    dErr = std::abs((dnu - err2) / (dnu + err2));
  }

  emxFree_real_T(&a);
  emxFree_real_T(&y);
  emxFree_real_T(&y2);
  emxFree_int32_T(&r2);
  emxFree_boolean_T(&r1);
  emxFree_boolean_T(&r);
  emxFree_real_T(&idx);
  return f_opt;
}

//
// %#codegen
//                % Length of a preambule in symbols
//               % Length of whole message in symbols
//               % QAM order
//  Preamble QAM symbol
// Arguments    : emxArray_real_T *data
//                double len
//                double Fs
//                double f_opt
//                double sps
//                double mode
//                double Pl
//                double msg_len
//                double M
//                double pre_qam
//                double *index_data
//                double *len_data
//                double f_est_data[]
//                int f_est_size[1]
//                double *warningStatus
// Return Type  : void
//
void HS_EWL_FREQ_ACQ(coder::comm::RaisedCosineReceiveFilter *b_rxFilter1,
                     boolean_T *b_rxFilter1_not_empty,
                     emxArray_real_T *data, double len, double Fs, double f_opt,
                     double sps, double mode, double Pl, double msg_len, double
                     M, double pre_qam, double *index_data, double *len_data,
                     double f_est_data[], int f_est_size[1], double
                     *warningStatus)
{
  emxArray_creal_T *b_testSignal;
  emxArray_creal_T *r;
  emxArray_real_T *s2;
  emxArray_real_T *t0;
  emxArray_real_T *testSignal;
  emxArray_real_T *tt;
  creal_T z2_data[255];
  double b_x[5];
  double b_sps[2];
  double endPreamPoint_im;
  double endPreamPoint_re;
  double pre_from;
  double receiveByteLen;
  double startPreamPoint_im;
  double startPreamPoint_re;
  int z2_size[2];
  int i;
  int i1;
  int loop_ub;
  int nx;
  short ii_data[1];

  extern double ref_cos[];
  extern double ref_sin[];

  if (!isInitialized_HS_EWL_DEMOD_QAM) {
    HS_EWL_DEMOD_QAM_initialize(b_rxFilter1, b_rxFilter1_not_empty);
  }

  //  function f_est =  HS_EWL_FREQ_ACQ(data, len, Fs, f_opt, mode, ... %#codegen 
  //      Pl          ,...               % Length of a preambule in symbols
  //      msg_len     ,...              % Length of whole message in symbols     
  //      M           ,...              % QAM order
  //      pre_qam        )           % Preamble QAM symbol)
  //  persistent rxFilter1;
  //  if isempty(rxFilter1)
  //      rxFilter1 = HS_EWL_FREQ_ACQ_INIT();
  //  end
  //
  //  f_est = HS_EWL_FREQ_ACQ_APPLY(data, len, Fs, f_opt, mode,rxFilter1, Pl, msg_len, M, pre_qam); 
  //
  //  end
  //
  //  function filter = HS_EWL_FREQ_ACQ_INIT()
  //
  //  filter = comm.RaisedCosineReceiveFilter(...
  //          'Shape','Square root',...
  //          'RolloffFactor',0.9, ...
  //          'FilterSpanInSymbols',10, ...
  //          'InputSamplesPerSymbol',8,'DecimationFactor',8);
  //  end
  *warningStatus = 0.0;
  receiveByteLen = rt_roundd_snf(len / sps);
  if (receiveByteLen < msg_len) {
    i = data->size[1];
    receiveByteLen = (msg_len - receiveByteLen) * sps;
    nx = static_cast<int>(receiveByteLen);
    i1 = data->size[0] * data->size[1];
    data->size[1] += static_cast<int>(receiveByteLen);
    emxEnsureCapacity_real_T(data, i1);
    for (i1 = 0; i1 < nx; i1++) {
      data->data[i + i1] = 0.0;
    }

    len += receiveByteLen;
    *warningStatus = 1.0;
  }

  emxInit_real_T(&t0, 2);

  // load
  // generate time vector
  f_est_size[0] = 1;
  f_est_data[0] = 0.0;

  // init value
  *index_data = 0.0;
  *len_data = 0.0;
  if (rtIsNaN(len)) {
    i = t0->size[0] * t0->size[1];
    t0->size[0] = 1;
    t0->size[1] = 1;
    emxEnsureCapacity_real_T(t0, i);
    t0->data[0] = rtNaN;
  } else if (len < 1.0) {
    t0->size[0] = 1;
    t0->size[1] = 0;
  } else if (rtIsInf(len) && (1.0 == len)) {
    i = t0->size[0] * t0->size[1];
    t0->size[0] = 1;
    t0->size[1] = 1;
    emxEnsureCapacity_real_T(t0, i);
    t0->data[0] = rtNaN;
  } else {
    i = t0->size[0] * t0->size[1];
    t0->size[0] = 1;
    loop_ub = static_cast<int>(std::floor(len - 1.0));
    t0->size[1] = loop_ub + 1;
    emxEnsureCapacity_real_T(t0, i);
    for (i = 0; i <= loop_ub; i++) {
      t0->data[i] = static_cast<double>(i) + 1.0;
    }
  }

  i = t0->size[0] * t0->size[1];
  i1 = t0->size[0] * t0->size[1];
  t0->size[0] = 1;
  emxEnsureCapacity_real_T(t0, i1);
  loop_ub = i - 1;
  for (i = 0; i <= loop_ub; i++) {
    t0->data[i] /= Fs;
  }

  if (!*b_rxFilter1_not_empty) {
    b_rxFilter1->init();
    *b_rxFilter1_not_empty = true;
  }

  startPreamPoint_re = 0.0;
  startPreamPoint_im = 0.0;
  endPreamPoint_re = 0.0;
  endPreamPoint_im = 0.0;

  //  preamble window
  //  dispersion for reamble point
  //  find preamble start
  pre_from = preambule_from(data, len);
  emxInit_real_T(&s2, 2);
  emxInit_real_T(&testSignal, 1);
  emxInit_real_T(&tt, 1);
  emxInit_creal_T(&r, 1);
  emxInit_creal_T(&b_testSignal, 1);
  if ((pre_from < 0.0) || (rt_roundd_snf(pre_from / sps) > 50.0)) {
    *warningStatus = 2.0;
  } else {
    creal_T x;
    double Fd;
    double a;
    double del_re;
    double endPreamPoint_re_tmp;
    double startPreamPoint_re_tmp;
    int k;
    boolean_T exitg1;

    // find preamble end
    receiveByteLen = pre_from + sps * (msg_len - 5.0);
    if (receiveByteLen > len) {
      if (pre_from > len) {
        i = -1;
        i1 = -1;
      } else {
        i = static_cast<int>(pre_from) - 2;
        i1 = static_cast<int>(len) - 1;
      }

      nx = static_cast<int>(receiveByteLen - len);
      k = s2->size[0] * s2->size[1];
      s2->size[0] = 1;
      loop_ub = i1 - i;
      s2->size[1] = loop_ub + nx;
      emxEnsureCapacity_real_T(s2, k);
      for (k = 0; k < loop_ub; k++) {
        s2->data[k] = data->data[(i + k) + 1];
      }

      for (k = 0; k < nx; k++) {
        s2->data[(k + i1) - i] = 0.0;
      }

      receiveByteLen = coder::internal::maximum(s2);
      i = s2->size[0] * s2->size[1];
      i1 = s2->size[0] * s2->size[1];
      s2->size[0] = 1;
      emxEnsureCapacity_real_T(s2, i1);
      loop_ub = i - 1;
      for (i = 0; i <= loop_ub; i++) {
        s2->data[i] /= receiveByteLen;
      }

      *index_data = pre_from;
      *len_data = s2->size[1];
      *warningStatus = 3.0;
    } else {
      if (pre_from > receiveByteLen) {
        i = 0;
        i1 = 0;
      } else {
        i = static_cast<int>(pre_from) - 1;
        i1 = static_cast<int>(receiveByteLen);
      }

      k = s2->size[0] * s2->size[1];
      s2->size[0] = 1;
      loop_ub = i1 - i;
      s2->size[1] = loop_ub;
      emxEnsureCapacity_real_T(s2, k);
      for (i1 = 0; i1 < loop_ub; i1++) {
        s2->data[i1] = data->data[i + i1];
      }

      receiveByteLen = coder::internal::maximum(s2);
      i1 = s2->size[0] * s2->size[1];
      s2->size[0] = 1;
      s2->size[1] = loop_ub;
      emxEnsureCapacity_real_T(s2, i1);
      for (i1 = 0; i1 < loop_ub; i1++) {
        s2->data[i1] = data->data[i + i1] / receiveByteLen;
      }

      *index_data = pre_from;
      *len_data = s2->size[1];

      //      warningStatus = warningStatusLocal;
    }

    //  normalizing
    if (1 > s2->size[1]) {
      loop_ub = 0;
    } else {
      loop_ub = s2->size[1];
    }

    // get bounds for processing
    // stage 1 freq estimation
    if (mode == 1.0) {
      i = testSignal->size[0];
      testSignal->size[0] = loop_ub;
      emxEnsureCapacity_real_T(testSignal, i);
      for (i = 0; i < loop_ub; i++) {
        testSignal->data[i] = t0->data[i];
      }

      i = tt->size[0];
      tt->size[0] = s2->size[1];
      emxEnsureCapacity_real_T(tt, i);
      loop_ub = s2->size[1];
      for (i = 0; i < loop_ub; i++) {
        tt->data[i] = s2->data[i];
      }

      receiveByteLen = sps * (Pl - 2.0);
      b_sps[0] = receiveByteLen;
      b_sps[1] = static_cast<double>(s2->size[1]) - receiveByteLen;
      f_opt = optimize_sin(testSignal, tt, b_sps, f_opt);
    }

    //  Recover modulation frequency (stage 2)
    Fd = f_opt * sps;
    coder::rat(Fd / Fs, &receiveByteLen, &pre_from);
    lagrange_resamp(s2, receiveByteLen, pre_from, testSignal);
    receiveByteLen = static_cast<double>(testSignal->size[0]) / sps;
    if (receiveByteLen < 0.0) {
      receiveByteLen = std::ceil(receiveByteLen);
    } else {
      receiveByteLen = std::floor(receiveByteLen);
    }

    receiveByteLen = receiveByteLen * sps - 1.0;
//    if (rtIsNaN(receiveByteLen)) {
//      i = t0->size[0] * t0->size[1];
//      t0->size[0] = 1;
//      t0->size[1] = 1;
//      emxEnsureCapacity_real_T(t0, i);
//      t0->data[0] = rtNaN;
//    } else if (receiveByteLen < 0.0) {
//      t0->size[0] = 1;
//      t0->size[1] = 0;
//    } else if (rtIsInf(receiveByteLen) && (0.0 == receiveByteLen)) {
//      i = t0->size[0] * t0->size[1];
//      t0->size[0] = 1;
//      t0->size[1] = 1;
//      emxEnsureCapacity_real_T(t0, i);
//      t0->data[0] = rtNaN;
//    } else {
//      i = t0->size[0] * t0->size[1];
//      t0->size[0] = 1;
//      loop_ub = static_cast<int>(std::floor(receiveByteLen));
//      t0->size[1] = loop_ub + 1;
//      emxEnsureCapacity_real_T(t0, i);
//      for (i = 0; i <= loop_ub; i++) {
//        t0->data[i] = i;
//      }
//    }

    // time
//    i = tt->size[0];
//    tt->size[0] = t0->size[1];
//    emxEnsureCapacity_real_T(tt, i);
//    loop_ub = t0->size[1];
//    for (i = 0; i < loop_ub; i++) {
//      tt->data[i] = t0->data[i] / Fd;
//    }

    //  coder.varsize('y', [16384000, 1]);
//    if (1 > tt->size[0]) {
//      loop_ub = 0;
//    } else {
//      loop_ub = static_cast<int>(std::floor(receiveByteLen));
//      loop_ub = loop_ub + 1;
//    }
    loop_ub = static_cast<int>(std::floor(receiveByteLen));
    loop_ub = loop_ub + 1;

//    del_re = f_opt * 0.0;
//    receiveByteLen = f_opt * 6.2831853071795862;
    i = r->size[0];
    r->size[0] = loop_ub;
    emxEnsureCapacity_creal_T(r, i);
//    nx = tt->size[0];
//    for (i = 0; i < nx; i++) {
//      r->data[i].re = tt->data[i] * del_re;
//      r->data[i].im = tt->data[i] * receiveByteLen;
//    }

    k = 0;
    nx = static_cast<double>(sps);
    for (int j = 0; j < loop_ub; j++) {
        r->data[j].re = ref_cos[k];//b_r * (b_r * std::cos(r->data[k].im));
        r->data[j].im = ref_sin[k];//b_r * (b_r * std::sin(r->data[k].im));
        k += 1;
        if (k == nx)
            k = 0;
    }

//    nx = r->size[0];
//    for (k = 0; k < nx; k++) {
//      if (r->data[k].im == 0.0) {
//        r->data[k].re = std::exp(r->data[k].re);
//        r->data[k].im = 0.0;
//      } else if (rtIsInf(r->data[k].im) && rtIsInf(r->data[k].re) && (r->data[k]
//                  .re < 0.0)) {
//        r->data[k].re = 0.0;
//        r->data[k].im = 0.0;
//      } else {
//        receiveByteLen = std::exp(r->data[k].re / 2.0);
//        r->data[k].re = receiveByteLen * (receiveByteLen * std::cos(r->data[k].
//          im));
//        r->data[k].im = receiveByteLen * (receiveByteLen * std::sin(r->data[k].
//          im));
//      }
//    }

    receiveByteLen = sps * 10.0 / 2.0;
    if (rtIsNaN(receiveByteLen)) {
      i = t0->size[0] * t0->size[1];
      t0->size[0] = 1;
      t0->size[1] = 1;
      emxEnsureCapacity_real_T(t0, i);
      t0->data[0] = rtNaN;
    } else if (receiveByteLen < 1.0) {
      t0->size[0] = 1;
      t0->size[1] = 0;
    } else if (rtIsInf(receiveByteLen) && (1.0 == receiveByteLen)) {
      i = t0->size[0] * t0->size[1];
      t0->size[0] = 1;
      t0->size[1] = 1;
      emxEnsureCapacity_real_T(t0, i);
      t0->data[0] = rtNaN;
    } else {
      i = t0->size[0] * t0->size[1];
      t0->size[0] = 1;
      nx = static_cast<int>(std::floor(receiveByteLen - 1.0));
      t0->size[1] = nx + 1;
      emxEnsureCapacity_real_T(t0, i);
      for (i = 0; i <= nx; i++) {
        t0->data[i] = 0.0;
      }
    }

    //  For compensate filter delay
    i = b_testSignal->size[0];
    b_testSignal->size[0] = loop_ub + t0->size[1];
    emxEnsureCapacity_creal_T(b_testSignal, i);
    for (i = 0; i < loop_ub; i++) {
      b_testSignal->data[i].re = 2.0 * (testSignal->data[i] * r->data[i].re);
      b_testSignal->data[i].im = 2.0 * (testSignal->data[i] * r->data[i].im);
    }

    nx = t0->size[1];
    for (i = 0; i < nx; i++) {
      i1 = i + loop_ub;
      b_testSignal->data[i1].re = t0->data[i];
      b_testSignal->data[i1].im = 0.0;
    }

    b_rxFilter1->step(b_testSignal, z2_data, z2_size);

    //  for i = 1:Pl*2-pre_win
    //      if sum(abs(real(z2(i:i+pre_win-1,1))))/pre_win ...
    //              >= (abs(real(z2(i)))- disp_pre) ...
    //              && sum(abs(real(z2(i:i+pre_win-1,1))))/pre_win ...
    //              <= (abs(real(z2(i)))+ disp_pre)
    //          startPreamPoint = z2(i+fix(pre_win/2),1);
    //          break;
    //      else
    //          startPreamPoint = z2(span/2 + pre_shift,1);
    //      end
    //  end
    pre_from = 0.0;
    Fd = (Pl * 2.0 + 6.0) - 5.0;
    nx = 0;
    exitg1 = false;
    while ((!exitg1) && (nx <= static_cast<int>(Fd + -5.0) - 1)) {
      receiveByteLen = std::abs(z2_data[nx + 5].re) - std::abs(z2_data[nx + 6].
        re);
      if ((receiveByteLen <= 0.15) && (receiveByteLen >= -0.15)) {
        pre_from++;
        if (pre_from == 5.0) {
          startPreamPoint_re = z2_data[static_cast<int>((static_cast<double>(nx)
            + 6.0) - 2.0) - 1].re;
          startPreamPoint_im = z2_data[static_cast<int>((static_cast<double>(nx)
            + 6.0) - 2.0) - 1].im;
          exitg1 = true;
        } else {
          nx++;
        }
      } else {
        pre_from = 0.0;
        startPreamPoint_re = z2_data[9].re;
        startPreamPoint_im = z2_data[9].im;
        nx++;
      }
    }

    pre_from = 0.0;

    //  for i = length(z2)-(Pl*2-1):length(z2)
    //      if abs(real(z2(i))) - abs(real(z2(i+1))) <= 0 + disp_pre && abs(real(z2(i))) - abs(real(z2(i+1))) >= 0 - disp_pre 
    //          preamble_count = preamble_count +1;
    //          if preamble_count == pre_win
    //              endPreamPoint = z2(i-fix(pre_win/2),1);
    //              break;
    //          end
    //          continue;
    //      else
    //          preamble_count = 0;
    //          endPreamPoint = z2(245 - pre_shift,1);
    //      end
    //  end
    //  del = qammod(pre_qam,M,'gray')/startPreamPoint;
    if ((z2_size[0] == 0) || (z2_size[1] == 0)) {
      k = 0;
    } else {
      k = z2_size[0];
      if (k <= 1) {
        k = 1;
      }
    }

    if ((z2_size[0] == 0) || (z2_size[1] == 0)) {
      nx = 0;
    } else {
      nx = z2_size[0];
      if (nx <= 1) {
        nx = 1;
      }
    }

    i = static_cast<int>(((static_cast<double>(nx) - (Pl * 2.0 - 1.0)) + (-1.0 -
      (static_cast<double>(k) - 1.0))) / -1.0);
    nx = 0;
    exitg1 = false;
    while ((!exitg1) && (nx <= i - 1)) {
      boolean_T guard1 = false;
      receiveByteLen = (static_cast<double>(k) - 1.0) + -static_cast<double>(nx);
      Fd = std::abs(z2_data[static_cast<int>(receiveByteLen) - 1].re) - std::abs
        (z2_data[static_cast<int>(receiveByteLen)].re);
      guard1 = false;
      if ((Fd <= 0.15) && (Fd >= -0.15)) {
        for (i1 = 0; i1 < 5; i1++) {
          b_x[i1] = z2_data[(i1 + static_cast<int>(receiveByteLen)) - 4].re;
        }

        if (!(((((b_x[0] + b_x[1]) + b_x[2]) + b_x[3]) + b_x[4]) / 5.0 <= 0.15))
        {
          for (i1 = 0; i1 < 5; i1++) {
            b_x[i1] = z2_data[(i1 + static_cast<int>(receiveByteLen)) - 4].re;
          }

          if (!(((((b_x[0] + b_x[1]) + b_x[2]) + b_x[3]) + b_x[4]) / 5.0 >=
                -0.15)) {
            pre_from++;
            if (pre_from == 5.0) {
              endPreamPoint_re = z2_data[static_cast<int>(receiveByteLen) - 3].
                re;
              endPreamPoint_im = z2_data[static_cast<int>(receiveByteLen) - 3].
                im;
              exitg1 = true;
            } else {
              nx++;
            }
          } else {
            guard1 = true;
          }
        } else {
          guard1 = true;
        }
      } else {
        guard1 = true;
      }

      if (guard1) {
        pre_from = 0.0;
        endPreamPoint_re = z2_data[239].re;
        endPreamPoint_im = z2_data[239].im;
        nx++;
      }
    }

    x = coder::qammod(pre_qam, M);
    if (startPreamPoint_im == 0.0) {
      if (x.im == 0.0) {
        del_re = x.re / startPreamPoint_re;
        receiveByteLen = 0.0;
      } else if (x.re == 0.0) {
        del_re = 0.0;
        receiveByteLen = x.im / startPreamPoint_re;
      } else {
        del_re = x.re / startPreamPoint_re;
        receiveByteLen = x.im / startPreamPoint_re;
      }
    } else if (startPreamPoint_re == 0.0) {
      if (x.re == 0.0) {
        del_re = x.im / startPreamPoint_im;
        receiveByteLen = 0.0;
      } else if (x.im == 0.0) {
        del_re = 0.0;
        receiveByteLen = -(x.re / startPreamPoint_im);
      } else {
        del_re = x.im / startPreamPoint_im;
        receiveByteLen = -(x.re / startPreamPoint_im);
      }
    } else {
      Fd = std::abs(startPreamPoint_re);
      receiveByteLen = std::abs(startPreamPoint_im);
      if (Fd > receiveByteLen) {
        receiveByteLen = startPreamPoint_im / startPreamPoint_re;
        pre_from = startPreamPoint_re + receiveByteLen * startPreamPoint_im;
        del_re = (x.re + receiveByteLen * x.im) / pre_from;
        receiveByteLen = (x.im - receiveByteLen * x.re) / pre_from;
      } else if (receiveByteLen == Fd) {
        if (startPreamPoint_re > 0.0) {
          receiveByteLen = 0.5;
        } else {
          receiveByteLen = -0.5;
        }

        if (startPreamPoint_im > 0.0) {
          pre_from = 0.5;
        } else {
          pre_from = -0.5;
        }

        del_re = (x.re * receiveByteLen + x.im * pre_from) / Fd;
        receiveByteLen = (x.im * receiveByteLen - x.re * pre_from) / Fd;
      } else {
        receiveByteLen = startPreamPoint_re / startPreamPoint_im;
        pre_from = startPreamPoint_im + receiveByteLen * startPreamPoint_re;
        del_re = (receiveByteLen * x.re + x.im) / pre_from;
        receiveByteLen = (receiveByteLen * x.im - x.re) / pre_from;
      }
    }

    //  for i = length(z2)-(Pl*2-1):length(z2)-pre_win
    //      if sum(abs(real(z2(i:i+pre_win-1,1))))/pre_win ...
    //              >= (abs(real(z2(i)))- disp_pre) ...
    //              && sum(abs(real(z2(i:i+pre_win-1,1))))/pre_win ...
    //              <= (abs(real(z2(i)))+ disp_pre)
    //          endPreamPoint = z2(i+fix(pre_win/2),1);
    //          flag_end_pre = 0;
    //          continue;
    //      end
    //      if flag_end_pre == 0
    //          break;
    //      end
    //      if endPreamPoint == 0
    //          endPreamPoint = z2(245 - pre_shift,1);
    //      end
    //  end
    //  plot(z2*del,'b *');
    //  hold on
    //  plot(startPreamPoint*del,'r *');
    //  hold on
    //  plot(endPreamPoint*del,'r *');
    //  dist_preambules = sqrt((real(z2(span/2+preamb_shift)*del)-real(z2(end-preamb_shift)*del))^2 + (imag(z2(span/2+preamb_shift)*del)-imag(z2(end-preamb_shift)*del))^2); 
    //  if angle(z2(span/2+preamb_shift)*del)<angle(z2(end-preamb_shift)*del)
    //      dist_preambules = -dist_preambules;
    //  end
    startPreamPoint_re_tmp = startPreamPoint_re * del_re - startPreamPoint_im *
      receiveByteLen;
    endPreamPoint_re_tmp = endPreamPoint_re * del_re - endPreamPoint_im *
      receiveByteLen;
    a = startPreamPoint_re_tmp - endPreamPoint_re_tmp;
    Fd = startPreamPoint_re * receiveByteLen + startPreamPoint_im * del_re;
    pre_from = endPreamPoint_re * receiveByteLen + endPreamPoint_im * del_re;
    receiveByteLen = Fd - pre_from;
    receiveByteLen = std::sqrt(a * a + receiveByteLen * receiveByteLen);
    if (rt_atan2d_snf(Fd, startPreamPoint_re_tmp) < rt_atan2d_snf(pre_from,
         endPreamPoint_re_tmp)) {
      receiveByteLen = -receiveByteLen;
    }

    nx = 0;
    k = 1;
    loop_ub = 0;
    exitg1 = false;
    while ((!exitg1) && (loop_ub < 1001)) {
      if (dv[loop_ub] <= receiveByteLen) {
        nx = 1;
        ii_data[0] = static_cast<short>(loop_ub + 1);
        exitg1 = true;
      } else {
        loop_ub++;
      }
    }

    if (nx == 0) {
      k = 0;
    }

    f_est_size[0] = k;
    if (0 <= k - 1) {
      f_est_data[0] = f_opt - dv1[ii_data[0] - 1];
    }
  }
  if(f_est_data[0] < 33000 || f_est_data[0] > 37000){
      *warningStatus = 4.0;
  }

  emxFree_creal_T(&b_testSignal);
  emxFree_creal_T(&r);
  emxFree_real_T(&tt);
  emxFree_real_T(&testSignal);
  emxFree_real_T(&s2);
  emxFree_real_T(&t0);
}

//
// %#codegen
//                % Length of a preambule in symbols
//               % Length of whole message in symbols
//               % QAM order
//  Preamble QAM symbol
// Arguments    : void
// Return Type  : void
//
void HS_EWL_FREQ_ACQ_free(coder::comm::RaisedCosineReceiveFilter *b_rxFilter1)
{
  b_rxFilter1->matlabCodegenDestructor();
  b_rxFilter1->_pobj0.matlabCodegenDestructor();
}

//
// %#codegen
//                % Length of a preambule in symbols
//               % Length of whole message in symbols
//               % QAM order
//  Preamble QAM symbol
// Arguments    : void
// Return Type  : void
//
void HS_EWL_FREQ_ACQ_init(coder::comm::RaisedCosineReceiveFilter *b_rxFilter1,
                          boolean_T *b_rxFilter1_not_empty)
{
  emxInitStruct_RaisedCosineReceiveFilter(b_rxFilter1);
  *b_rxFilter1_not_empty = false;
  b_rxFilter1->_pobj0.matlabCodegenIsDeleted = true;
  b_rxFilter1->matlabCodegenIsDeleted = true;
}

//
// Arguments    : double idx
//                const double FF[50]
// Return Type  : double
//
double absolute_min(double idx, const double FF[50])
{
  static const short iv1[9] = { 2304, 2401, 2500, 48, 49, 50, 1, 1, 1 };

  static const signed char iv[9] = { 1, 4, 9, 1, 2, 3, 1, 1, 1 };

  double X[9];
  double Y[3];
  double a21;
  double maxval;
  double mn_idx;
  int r1;
  int r2;
  int r3;
  switch (static_cast<int>(idx)) {
   case 1:
    for (r1 = 0; r1 < 9; r1++) {
      X[r1] = iv[r1];
    }

    Y[0] = FF[0];
    Y[1] = FF[1];
    Y[2] = FF[2];
    break;

   case 50:
    for (r1 = 0; r1 < 9; r1++) {
      X[r1] = iv1[r1];
    }

    Y[0] = FF[47];
    Y[1] = FF[48];
    Y[2] = FF[49];
    break;

   default:
    X[0] = (idx - 1.0) * (idx - 1.0);
    X[3] = idx - 1.0;
    X[6] = 1.0;
    X[1] = idx * idx;
    X[4] = idx;
    X[7] = 1.0;
    X[2] = (idx + 1.0) * (idx + 1.0);
    X[5] = idx + 1.0;
    X[8] = 1.0;
    Y[0] = FF[static_cast<int>(idx - 1.0) - 1];
    Y[1] = FF[static_cast<int>(idx) - 1];
    Y[2] = FF[static_cast<int>(idx + 1.0) - 1];
    break;
  }

  r1 = 0;
  r2 = 1;
  r3 = 2;
  maxval = std::abs(X[0]);
  a21 = std::abs(X[1]);
  if (a21 > maxval) {
    maxval = a21;
    r1 = 1;
    r2 = 0;
  }

  if (std::abs(X[2]) > maxval) {
    r1 = 2;
    r2 = 1;
    r3 = 0;
  }

  X[r2] /= X[r1];
  X[r3] /= X[r1];
  X[r2 + 3] -= X[r2] * X[r1 + 3];
  X[r3 + 3] -= X[r3] * X[r1 + 3];
  X[r2 + 6] -= X[r2] * X[r1 + 6];
  X[r3 + 6] -= X[r3] * X[r1 + 6];
  if (std::abs(X[r3 + 3]) > std::abs(X[r2 + 3])) {
    int rtemp;
    rtemp = r2;
    r2 = r3;
    r3 = rtemp;
  }

  X[r3 + 3] /= X[r2 + 3];
  X[r3 + 6] -= X[r3 + 3] * X[r2 + 6];
  a21 = Y[r2] - Y[r1] * X[r2];
  maxval = ((Y[r3] - Y[r1] * X[r3]) - a21 * X[r3 + 3]) / X[r3 + 6];
  a21 -= maxval * X[r2 + 6];
  a21 /= X[r2 + 3];
  maxval = ((Y[r1] - maxval * X[r1 + 6]) - a21 * X[r1 + 3]) / X[r1];
  if (maxval > 0.0) {
    mn_idx = -a21 / 2.0 / maxval;
  } else {
    mn_idx = idx;
  }

  return mn_idx;
}

//
// Arguments    : const emxArray_real_T *s
//                double len
// Return Type  : double
//
double preambule_from(const emxArray_real_T *s, double len)
{
  double position[4];
  double count;
  double pre_from;
  double sa;
  int flag_amp;
  int i;
  int vlen_tmp;
  boolean_T exitg1;
  position[0] = 0.0;
  position[1] = 0.0;
  position[2] = 0.0;
  position[3] = 0.0;
  count = 0.0;
  flag_amp = 1;

  // win = s(i:i+win_len-1);
  i = 0;
  exitg1 = false;
  while ((!exitg1) && (i <= static_cast<int>(len - 11.0) - 1)) {
    int b_i;
    if (static_cast<double>(i) + 1.0 > ((static_cast<double>(i) + 1.0) + 11.0) -
        1.0) {
      b_i = -1;
      vlen_tmp = -1;
    } else {
      b_i = i - 1;
      vlen_tmp = static_cast<int>(((static_cast<double>(i) + 1.0) + 11.0) - 1.0)
        - 1;
    }

    vlen_tmp -= b_i;
    if (vlen_tmp == 0) {
      sa = 0.0;
    } else {
      sa = s->data[b_i + 1];
      for (int k = 2; k <= vlen_tmp; k++) {
        sa += s->data[b_i + k];
      }
    }

    sa /= static_cast<double>(vlen_tmp);
    if ((sa > 0.2) && (flag_amp == 1)) {
      count++;
      position[static_cast<int>(count) - 1] = static_cast<double>(i) + 1.0;
      flag_amp = 0;
    }

    if (sa < -0.2) {
      flag_amp = 1;
    }

    if (count == 4.0) {
      exitg1 = true;
    } else {
      i++;
    }
  }

  if (count > 0.0) {
    pre_from = position[static_cast<int>(count) - 1];
  } else {
    pre_from = -1.0;
  }

  return pre_from;
}

//
// File trailer for HS_EWL_FREQ_ACQ.cpp
//
// [EOF]
//
